// Code generated by mockery v2.42.1. DO NOT EDIT.

package aws

import (
	context "context"

	acm "github.com/aws/aws-sdk-go-v2/service/acm"

	mock "github.com/stretchr/testify/mock"
)

// MockacmApi is an autogenerated mock type for the acmApi type
type MockacmApi struct {
	mock.Mock
}

type MockacmApi_Expecter struct {
	mock *mock.Mock
}

func (_m *MockacmApi) EXPECT() *MockacmApi_Expecter {
	return &MockacmApi_Expecter{mock: &_m.Mock}
}

// DeleteCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *MockacmApi) DeleteCertificate(ctx context.Context, params *acm.DeleteCertificateInput, optFns ...func(*acm.Options)) (*acm.DeleteCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCertificate")
	}

	var r0 *acm.DeleteCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *acm.DeleteCertificateInput, ...func(*acm.Options)) (*acm.DeleteCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *acm.DeleteCertificateInput, ...func(*acm.Options)) *acm.DeleteCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acm.DeleteCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *acm.DeleteCertificateInput, ...func(*acm.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockacmApi_DeleteCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCertificate'
type MockacmApi_DeleteCertificate_Call struct {
	*mock.Call
}

// DeleteCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *acm.DeleteCertificateInput
//   - optFns ...func(*acm.Options)
func (_e *MockacmApi_Expecter) DeleteCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *MockacmApi_DeleteCertificate_Call {
	return &MockacmApi_DeleteCertificate_Call{Call: _e.mock.On("DeleteCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockacmApi_DeleteCertificate_Call) Run(run func(ctx context.Context, params *acm.DeleteCertificateInput, optFns ...func(*acm.Options))) *MockacmApi_DeleteCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*acm.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*acm.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*acm.DeleteCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *MockacmApi_DeleteCertificate_Call) Return(_a0 *acm.DeleteCertificateOutput, _a1 error) *MockacmApi_DeleteCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockacmApi_DeleteCertificate_Call) RunAndReturn(run func(context.Context, *acm.DeleteCertificateInput, ...func(*acm.Options)) (*acm.DeleteCertificateOutput, error)) *MockacmApi_DeleteCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *MockacmApi) DescribeCertificate(ctx context.Context, params *acm.DescribeCertificateInput, optFns ...func(*acm.Options)) (*acm.DescribeCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCertificate")
	}

	var r0 *acm.DescribeCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *acm.DescribeCertificateInput, ...func(*acm.Options)) (*acm.DescribeCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *acm.DescribeCertificateInput, ...func(*acm.Options)) *acm.DescribeCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acm.DescribeCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *acm.DescribeCertificateInput, ...func(*acm.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockacmApi_DescribeCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCertificate'
type MockacmApi_DescribeCertificate_Call struct {
	*mock.Call
}

// DescribeCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *acm.DescribeCertificateInput
//   - optFns ...func(*acm.Options)
func (_e *MockacmApi_Expecter) DescribeCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *MockacmApi_DescribeCertificate_Call {
	return &MockacmApi_DescribeCertificate_Call{Call: _e.mock.On("DescribeCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockacmApi_DescribeCertificate_Call) Run(run func(ctx context.Context, params *acm.DescribeCertificateInput, optFns ...func(*acm.Options))) *MockacmApi_DescribeCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*acm.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*acm.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*acm.DescribeCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *MockacmApi_DescribeCertificate_Call) Return(_a0 *acm.DescribeCertificateOutput, _a1 error) *MockacmApi_DescribeCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockacmApi_DescribeCertificate_Call) RunAndReturn(run func(context.Context, *acm.DescribeCertificateInput, ...func(*acm.Options)) (*acm.DescribeCertificateOutput, error)) *MockacmApi_DescribeCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// ImportCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *MockacmApi) ImportCertificate(ctx context.Context, params *acm.ImportCertificateInput, optFns ...func(*acm.Options)) (*acm.ImportCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ImportCertificate")
	}

	var r0 *acm.ImportCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ImportCertificateInput, ...func(*acm.Options)) (*acm.ImportCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ImportCertificateInput, ...func(*acm.Options)) *acm.ImportCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acm.ImportCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *acm.ImportCertificateInput, ...func(*acm.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockacmApi_ImportCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportCertificate'
type MockacmApi_ImportCertificate_Call struct {
	*mock.Call
}

// ImportCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *acm.ImportCertificateInput
//   - optFns ...func(*acm.Options)
func (_e *MockacmApi_Expecter) ImportCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *MockacmApi_ImportCertificate_Call {
	return &MockacmApi_ImportCertificate_Call{Call: _e.mock.On("ImportCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockacmApi_ImportCertificate_Call) Run(run func(ctx context.Context, params *acm.ImportCertificateInput, optFns ...func(*acm.Options))) *MockacmApi_ImportCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*acm.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*acm.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*acm.ImportCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *MockacmApi_ImportCertificate_Call) Return(_a0 *acm.ImportCertificateOutput, _a1 error) *MockacmApi_ImportCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockacmApi_ImportCertificate_Call) RunAndReturn(run func(context.Context, *acm.ImportCertificateInput, ...func(*acm.Options)) (*acm.ImportCertificateOutput, error)) *MockacmApi_ImportCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// ListCertificates provides a mock function with given fields: ctx, params, optFns
func (_m *MockacmApi) ListCertificates(ctx context.Context, params *acm.ListCertificatesInput, optFns ...func(*acm.Options)) (*acm.ListCertificatesOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCertificates")
	}

	var r0 *acm.ListCertificatesOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ListCertificatesInput, ...func(*acm.Options)) (*acm.ListCertificatesOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ListCertificatesInput, ...func(*acm.Options)) *acm.ListCertificatesOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acm.ListCertificatesOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *acm.ListCertificatesInput, ...func(*acm.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockacmApi_ListCertificates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCertificates'
type MockacmApi_ListCertificates_Call struct {
	*mock.Call
}

// ListCertificates is a helper method to define mock.On call
//   - ctx context.Context
//   - params *acm.ListCertificatesInput
//   - optFns ...func(*acm.Options)
func (_e *MockacmApi_Expecter) ListCertificates(ctx interface{}, params interface{}, optFns ...interface{}) *MockacmApi_ListCertificates_Call {
	return &MockacmApi_ListCertificates_Call{Call: _e.mock.On("ListCertificates",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockacmApi_ListCertificates_Call) Run(run func(ctx context.Context, params *acm.ListCertificatesInput, optFns ...func(*acm.Options))) *MockacmApi_ListCertificates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*acm.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*acm.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*acm.ListCertificatesInput), variadicArgs...)
	})
	return _c
}

func (_c *MockacmApi_ListCertificates_Call) Return(_a0 *acm.ListCertificatesOutput, _a1 error) *MockacmApi_ListCertificates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockacmApi_ListCertificates_Call) RunAndReturn(run func(context.Context, *acm.ListCertificatesInput, ...func(*acm.Options)) (*acm.ListCertificatesOutput, error)) *MockacmApi_ListCertificates_Call {
	_c.Call.Return(run)
	return _c
}

// ListTagsForCertificate provides a mock function with given fields: ctx, params, optFns
func (_m *MockacmApi) ListTagsForCertificate(ctx context.Context, params *acm.ListTagsForCertificateInput, optFns ...func(*acm.Options)) (*acm.ListTagsForCertificateOutput, error) {
	_va := make([]interface{}, len(optFns))
	for _i := range optFns {
		_va[_i] = optFns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, params)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListTagsForCertificate")
	}

	var r0 *acm.ListTagsForCertificateOutput
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ListTagsForCertificateInput, ...func(*acm.Options)) (*acm.ListTagsForCertificateOutput, error)); ok {
		return rf(ctx, params, optFns...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *acm.ListTagsForCertificateInput, ...func(*acm.Options)) *acm.ListTagsForCertificateOutput); ok {
		r0 = rf(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*acm.ListTagsForCertificateOutput)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *acm.ListTagsForCertificateInput, ...func(*acm.Options)) error); ok {
		r1 = rf(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockacmApi_ListTagsForCertificate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTagsForCertificate'
type MockacmApi_ListTagsForCertificate_Call struct {
	*mock.Call
}

// ListTagsForCertificate is a helper method to define mock.On call
//   - ctx context.Context
//   - params *acm.ListTagsForCertificateInput
//   - optFns ...func(*acm.Options)
func (_e *MockacmApi_Expecter) ListTagsForCertificate(ctx interface{}, params interface{}, optFns ...interface{}) *MockacmApi_ListTagsForCertificate_Call {
	return &MockacmApi_ListTagsForCertificate_Call{Call: _e.mock.On("ListTagsForCertificate",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockacmApi_ListTagsForCertificate_Call) Run(run func(ctx context.Context, params *acm.ListTagsForCertificateInput, optFns ...func(*acm.Options))) *MockacmApi_ListTagsForCertificate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*acm.Options), len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*acm.Options))
			}
		}
		run(args[0].(context.Context), args[1].(*acm.ListTagsForCertificateInput), variadicArgs...)
	})
	return _c
}

func (_c *MockacmApi_ListTagsForCertificate_Call) Return(_a0 *acm.ListTagsForCertificateOutput, _a1 error) *MockacmApi_ListTagsForCertificate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockacmApi_ListTagsForCertificate_Call) RunAndReturn(run func(context.Context, *acm.ListTagsForCertificateInput, ...func(*acm.Options)) (*acm.ListTagsForCertificateOutput, error)) *MockacmApi_ListTagsForCertificate_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockacmApi creates a new instance of MockacmApi. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockacmApi(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockacmApi {
	mock := &MockacmApi{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
